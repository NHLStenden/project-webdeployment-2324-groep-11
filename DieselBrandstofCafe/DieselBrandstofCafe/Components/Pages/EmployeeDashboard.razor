@page "/dashboard"

@using DieselBrandstofCafe.Components.Data
@using DieselBrandstofCafe.Components.Models
@using System.Data.SqlClient
@using Microsoft.Extensions.Configuration.Json
@using Microsoft.Extensions.Configuration
@using System.Collections.Generic
@using System.Threading.Tasks
@using Dapper
@using System.Text.Json
@using System.Timers
@using DieselBrandstofCafe.Components.Comps

@inject IEmployeeService EmployeeService
@inject IManagerService ManagerService

<PageTitle>Dashboard</PageTitle>

<ConfirmationDialog @ref="confirmationDialog" />


<h1 class="page-title">Dashboard</h1>



<div class="order-count-cards">
    <div class="order-count-card">
        <i class="bi bi-clock"></i>
        <div class="order-count-card-text">
            <h2>@pendingCount</h2>
            <h3>Open Orders</h3>
        </div>
    </div>
    <div class="order-count-card">
        <i class="bi bi-clock-history"></i>
        <div class="order-count-card-text">
            <h2>@inProgressCount</h2>
            <h3>In Progress</h3>
        </div>
    </div>
    <div class="order-count-card">
        <i class="bi bi-clipboard2-check"></i>
        <div class="order-count-card-text">
            <h2>@completedCount</h2>
            <h3>Ready</h3>
        </div>
    </div>
</div>

<div class="orders-board">
    @if (pendingAndInProgressOrders.Count == 0 && completedOrders.Count == 0 && servedOrders.Count == 0 && cancelledOrders.Count == 0)
    {
        <h4 class="warning-text">No orders available</h4>
    }

    @RenderOrdersSection("Ongoing Orders", pendingAndInProgressOrders)
    @RenderOrdersSection("Ready Orders", completedOrders)
    @RenderOrdersSection("Served Orders", servedOrders)
    @RenderOrdersSection("Cancelled Orders", cancelledOrders)
</div>

@code {
    private List<OrderWithProducts> orders = new List<OrderWithProducts>();
    private List<OrderWithProducts> pendingAndInProgressOrders = new List<OrderWithProducts>();
    private List<OrderWithProducts> completedOrders = new List<OrderWithProducts>();
    private List<OrderWithProducts> servedOrders = new List<OrderWithProducts>();
    private List<OrderWithProducts> cancelledOrders = new List<OrderWithProducts>();

    private int pendingCount;
    private int inProgressCount;
    private int completedCount;
    private Timer? _timer;
    private ConfirmationDialog confirmationDialog;

    protected override async Task OnInitializedAsync()
    {
        await LoadOrdersByStatus();

        _timer = new Timer(1000); // Update every second
        _timer.Elapsed += async (sender, e) => await UpdateElapsedTime();
        _timer.Start();
    }

    private async Task LoadOrdersByStatus()
        {
            pendingAndInProgressOrders.Clear();
            completedOrders.Clear();
            servedOrders.Clear();
            cancelledOrders.Clear();

        var statuses = new[]
        {
            new { Status = "Pending", List = pendingAndInProgressOrders },
            new { Status = "In Progress", List = pendingAndInProgressOrders },
            new { Status = "Ready", List = completedOrders },
            new { Status = "Served", List = servedOrders },
            new { Status = "Cancelled", List = cancelledOrders }
        };

        pendingCount = 0;
        inProgressCount = 0;
        completedCount = 0;

        foreach (var status in statuses)
        {
            var orders = await EmployeeService.GetOrdersByStatusAsync(status.Status);

            foreach (var order in orders)
            {
                var products = await EmployeeService.GetProductsForBestelrondeAsync(order.BestelrondeID);
                order.Products = products.ToList();

                status.List.Add(order);

                switch (order.StatusBestelling)
                {
                    case "Pending":
                        pendingCount++;
                        break;
                    case "In Progress":
                        inProgressCount++;
                        break;
                    case "Ready":
                        completedCount++;
                        break;
                }
            }
        }

        pendingAndInProgressOrders = pendingAndInProgressOrders
        .OrderByDescending(o => o.StatusBestelling == "Pending")
        .ThenByDescending(o => o.BestelrondeID)
        .ToList();

        StateHasChanged();
    }


    private RenderFragment RenderOrdersSection(string title, List<OrderWithProducts> orders) =>
    @<div class="orders-section">
        <h3>@title</h3>
        <div class="orders-container">
            @foreach (var order in orders)
            {
            <div class="orders-card " key="@order.BestelrondeID">
                    <div class="todo-title-wrapper">
                        <div class="todo-table-status-container">
                            <h4 class="table-number">Table @order.TafelID</h4>
                            <h5 class="status-text @GetOrderStatusClass(order.StatusBestelling)">
                                @order.StatusBestelling @(":") @GetCompletionPercentage(order)%
                            </h5>
                        </div>
                        <div class="order-details-wrapper">
                            <h4 class="order-id">#@order.BestelrondeID</h4>
                            @if (order.StatusBestelling == "Pending" || order.StatusBestelling == "In Progress")
                        {
                            <div class="timer-container">
                                <i class="bi bi-clock-history @GetElapsedTimeClass(order)" />
                                <h5 class="elapsed-time @GetElapsedTimeClass(order)">@GetElapsedTimeText(order)</h5>
                            </div>
                        }
                        </div>
                    </div>
                    <ul class="product-list-title-wrapper">
                        <li class="product-list-title">Amt</li>
                        <li class="product-list-title">Product</li>
                        <li class="product-list-title">Status</li>
                    </ul>
                    <ul class="product-list-wrapper">
                        @foreach (var product in order.Products)
                    {
                        <button class="product-button @GetProductClass(product)" key="@($"{order.BestelrondeID}-{product.ProductID}")" @onclick="() => OnProductStatusChanged(order, product)">
                        <li class="@GetProductClass(product)" key="@($"{order.BestelrondeID}-{product.ProductID}")">
                            <span>@product.AantalProduct @("x")</span>
                            @product.ProductNaam
                            @if (product.StatusBesteldeProduct == "Ready")
                        {
                            <i class="bi bi-check-circle-fill tick-icon"></i>
                        }
                        else
                        {
                            <i class="bi bi-circle-fill circle-icon"></i>
                        }
                        </li>
                        </button>
                    }
                    </ul>
                    <div class="btns-container">
                        <button class="cancel-btn @(order.StatusBestelling != "Pending" ? "disabled" : "")" @onclick="() => OnCancelOrder(order)" disabled="@(order.StatusBestelling != "Pending")">Cancel</button>
                        <button class="serve-btn @(order.StatusBestelling != "Ready" ? "disabled" : "")" @onclick="() => OnServeOrder(order)" disabled="@(order.StatusBestelling != "Ready")">Serve</button>
                    </div>
                </div>
            }
        </div>
    </div>
    ;


    private bool GetProductStatus(ProductPerBestelronde product)
    {
        return product.StatusBesteldeProduct == "Ready";
    }

    private async Task OnProductStatusChanged(OrderWithProducts order, ProductPerBestelronde product)
    {
        if (product.StatusBesteldeProduct == "Ready")
        {
            await UncompleteTask(order, product);
        }
        else
        {
            await CompleteTask(order, product);
        }

        await LoadOrdersByStatus();
    }

    private async Task CompleteTask(OrderWithProducts order, ProductPerBestelronde product)
    {

        if (product.StatusBesteldeProduct == "Cancelled" || product.StatusBesteldeProduct == "Served")
        {
            confirmationDialog.Show($"The product is already {product.StatusBesteldeProduct} and cannot be changed.");
            return;

        }

        /*await EmployeeService.UpdateProductStatusAsync(product.ProductID, product.BestelrondeID, "Ready");
        product.StatusBesteldeProduct = "Ready";*/
        await EmployeeService.CompleteTaskAndUpdateProductStatusAsync(order.BestelrondeID, product.ProductID, "Ready");
        product.StatusBesteldeProduct = "Ready";

        var allProductsCompleted = await EmployeeService.AreAllProductsCompletedAsync(order.BestelrondeID);
        var anyProductsCompleted = await EmployeeService.AreAnyProductsCompletedAsync(order.BestelrondeID);

        //await UpdateOrderStatusAsync(order.BestellingID, allProductsCompleted, anyProductsCompleted);

        string newStatus;

        if (allProductsCompleted)
        {
            newStatus = "Ready";
        }
        else if (anyProductsCompleted)
        {
            newStatus = "In Progress";
        }
        else
        {
            newStatus = "Pending";
        }

        await EmployeeService.UpdateOrderStatusAsync(order.BestelrondeID, newStatus);

        //var existingOrder = pendingAndInProgressOrders.FirstOrDefault(o => o.BestellingID == order.BestellingID);
        var existingOrder = pendingAndInProgressOrders.FirstOrDefault(o => o.BestelrondeID == order.BestelrondeID);
        if (existingOrder != null)
        {
            order.CreationTime = existingOrder.CreationTime;
        }

        await LoadOrdersByStatus();
    }

    private async Task UncompleteTask(OrderWithProducts order, ProductPerBestelronde product)
    {
        if (product.StatusBesteldeProduct == "Cancelled" || product.StatusBesteldeProduct == "Served")
        {
            confirmationDialog.Show($"The product is already {product.StatusBesteldeProduct} and cannot be changed.");
            return;

        }

        /*await EmployeeService.UpdateProductStatusAsync(product.ProductID, product.BestelrondeID, "Pending");
        product.StatusBesteldeProduct = "Pending";*/
        await EmployeeService.CompleteTaskAndUpdateProductStatusAsync(order.BestelrondeID, product.ProductID, "Pending");
        product.StatusBesteldeProduct = "Pending";

        var allProductsCompleted = await EmployeeService.AreAllProductsCompletedAsync(order.BestelrondeID);
        var anyProductsCompleted = await EmployeeService.AreAnyProductsCompletedAsync(order.BestelrondeID);


        //await UpdateOrderStatusAsync(order.BestellingID, allProductsCompleted, anyProductsCompleted);

        string newStatus;

        if (allProductsCompleted)
        {
            newStatus = "Ready";
        }
        else if (anyProductsCompleted)
        {
            newStatus = "In Progress";
        }
        else
        {
            newStatus = "Pending";
        }

        await EmployeeService.UpdateOrderStatusAsync(order.BestelrondeID, newStatus);


        //var existingOrder = pendingAndInProgressOrders.FirstOrDefault(o => o.BestellingID == order.BestellingID);
        var existingOrder = pendingAndInProgressOrders.FirstOrDefault(o => o.BestelrondeID == order.BestelrondeID);

        if (existingOrder != null)
        {
            order.CreationTime = existingOrder.CreationTime;
        }

        await LoadOrdersByStatus();
    }

    //private async Task UpdateOrderStatusAsync(int bestellingId, bool allProductsCompleted, bool anyProductsCompleted)
    private async Task UpdateOrderStatusAsync(int bestelrondeId, bool allProductsCompleted, bool anyProductsCompleted)
    {
        string status;

        switch ((allProductsCompleted, anyProductsCompleted))
        {
            case (true, _):
                status = "Ready";
                break;
            case (false, true):
                status = "In Progress";
                break;
            case (false, false):
                status = "Pending";
                break;
        }

        //await EmployeeService.UpdateOrderStatusAsync(bestellingId, status);
        await EmployeeService.UpdateOrderStatusAsync(bestelrondeId, status);
    }

    private async Task OnCancelOrder(OrderWithProducts order)
    {
        //await EmployeeService.UpdateOrderStatusAsync(order.BestellingID, "Cancelled");
        /*await EmployeeService.UpdateOrderStatusAsync(order.BestelrondeID, "Cancelled");
        */

        foreach (var product in order.Products)
        {
            await EmployeeService.CompleteTaskAndUpdateProductStatusAsync(order.BestelrondeID, product.ProductID, "Cancelled");
        }

        await EmployeeService.UpdateOrderStatusAsync(order.BestelrondeID, "Cancelled");
        order.StatusBestelling = "Cancelled";
        await LoadOrdersByStatus();
    }

    private async Task OnServeOrder(OrderWithProducts order)
    {
        //await EmployeeService.UpdateOrderStatusAsync(order.BestellingID, "Served");
        /*await EmployeeService.UpdateOrderStatusAsync(order.BestelrondeID, "Served");
        */

        foreach (var product in order.Products)
        {
            await EmployeeService.CompleteTaskAndUpdateProductStatusAsync(order.BestelrondeID, product.ProductID, "Served");
        }

        await EmployeeService.UpdateOrderStatusAsync(order.BestelrondeID, "Served");
        order.StatusBestelling = "Served";

        await LoadOrdersByStatus();
    }

    private string GetProductClass(ProductPerBestelronde product)
    {
        return product.StatusBesteldeProduct == "Served" || product.StatusBesteldeProduct == "Ready" || product.StatusBesteldeProduct == "Cancelled" ? "completed-product" : string.Empty;
    }

    /*private string GetOrderClass(OrderWithProducts order)
    {
        //return order.StatusBestelling == "Ready" ? "" : string.Empty;
        return order.StatusBestelling == "Ready" ? "completed-product" : string.Empty;
    }*/

    private string GetOrderStatusClass(string status)
    {
        return status switch
        {
            "Pending" => "status_pending",
            "In Progress" => "status_in-progress",
            "Ready" => "status_completed",
            "Served" => "status_served",
            "Cancelled" => "status_cancelled",
            _ => string.Empty,
        };
    }

    private double GetCompletionPercentage(OrderWithProducts order)
    {
        if (order.StatusBestelling == "Cancelled" || order.StatusBestelling == "Served")
        {
            return 100;
        }

        if (order.Products == null || order.Products.Count == 0) return 0;

        var completedProducts = order.Products.Count(p => p.StatusBesteldeProduct == "Ready");
        var percentage = (completedProducts / (double)order.Products.Count) * 100;
        return Math.Round(percentage);
    }

    private async Task UpdateElapsedTime()
    {
        await InvokeAsync(StateHasChanged); // Ensure the UI updates
    }

    private string GetElapsedTimeText(OrderWithProducts order)
    {

        var elapsed = DateTime.Now - order.CreationTime;
        int totalMinutes = (int)elapsed.TotalMinutes;
        return $"{totalMinutes} min";
    }

    private string GetElapsedTimeClass(OrderWithProducts order)
    {
        var elapsed = DateTime.Now - order.CreationTime;

        if (elapsed.TotalMinutes < 15)
        {
            return "elapsed-time-short";
        }
        else if (elapsed.TotalMinutes < 35)
        {
            return "elapsed-time-medium";
        }
        else
        {
            return "elapsed-time-long";
        }
    }
}
