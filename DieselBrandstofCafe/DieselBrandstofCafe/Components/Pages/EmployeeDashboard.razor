@page "/dashboard"

@* Using directives to include necessary namespaces*@

@using DieselBrandstofCafe.Components.Data;
@using DieselBrandstofCafe.Components.Models;
@using System.Data.SqlClient;
@using Microsoft.Extensions.Configuration.Json;
@using Microsoft.Extensions.Configuration;
@using System.Collections.Generic;
@using System.Threading.Tasks;
@using Dapper;
@using System.Text.Json

@* Injecting the EmployeeService and ManagerService to access their methods *@
@inject IEmployeeService EmployeeService;
@inject IManagerService ManagerService;
@* Setting the title of the page *@
<PageTitle>Dashboard</PageTitle>



@* Main heading of the page *@
<h1 class="page-title">Dashboard</h1>

<div class="order-count-cards">
    <div class="order-count-card">
        <i class="bi bi-clock"></i>
        <div class="order-count-card-text">
            <h2> @pendingCount</h2>
            <h3>Open Orders</h3>
        </div>
    </div>
    <div class="order-count-card">
        <i class="bi bi-clock-history"></i>
        <div class="order-count-card-text">
            <h2> @inProgressCount</h2>
            <h3>In Progress</h3>
        </div>
    </div>
    <div class="order-count-card">
        <i class="bi bi-clipboard2-check"></i>
        <div class="order-count-card-text">
            <h2> @completedCount</h2>
            <h3>Completed</h3>
        </div>
    </div>
</div>

@* Orders board to display the list of orders *@
<div class="orders-board">

    @if (pendingAndInProgressOrders.Count == 0 && completedOrders.Count == 0 && servedOrders.Count == 0 && cancelledOrders.Count == 0)
    {
        // Message shown if there are no orders
        <h4 class="warning-text">No orders available</h4>
    }


    @RenderOrdersSection("Ongoing Orders", pendingAndInProgressOrders)
    @RenderOrdersSection("Completed Orders", completedOrders)
    @RenderOrdersSection("Served Orders", servedOrders)
    @RenderOrdersSection("Cancelled Orders", cancelledOrders)


</div>


@code {
    // Initialize the lists for their specific types. These are lists of objects that should hold the necessary data.
    private List<OrderWithProducts> orders = new List<OrderWithProducts>();


    private List<OrderWithProducts> pendingAndInProgressOrders = new List<OrderWithProducts>();
    private List<OrderWithProducts> completedOrders = new List<OrderWithProducts>();
    private List<OrderWithProducts> servedOrders = new List<OrderWithProducts>();
    private List<OrderWithProducts> cancelledOrders = new List<OrderWithProducts>();

    private int pendingCount;
    private int inProgressCount;
    private int completedCount;

    // This method runs during the OnInitialized lifecycle event of the component.
    protected override async Task OnInitializedAsync()
    {

        await LoadOrdersByStatus();


    }

    private async Task LoadOrdersByStatus()
    {
        pendingAndInProgressOrders.Clear();
        completedOrders.Clear();
        servedOrders.Clear();
        cancelledOrders.Clear();

        var statuses = new[]
        {
                new { Status = "Pending", List = pendingAndInProgressOrders },
                new { Status = "In Progress", List = pendingAndInProgressOrders },
                new { Status = "Completed", List = completedOrders },
                new { Status = "Served", List = servedOrders },
                new { Status = "Cancelled", List = cancelledOrders }
        };

        pendingCount = 0; inProgressCount = 0; completedCount = 0;

        foreach (var status in statuses)
        {
            var orders = await EmployeeService.GetOrdersByStatusAsync(status.Status);

            foreach (var order in orders)
            {
                var products = await EmployeeService.GetProductsForOrderAsync(order.BestellingID);
                var orderWithProducts = new OrderWithProducts
                {
                    BestellingID = order.BestellingID,
                    TafelID = order.TafelID,
                    Products = products.ToList(),
                    StatusBestelling = order.StatusBestelling
                };

                status.List.Add(orderWithProducts);

                // Update the counts
                switch (order.StatusBestelling)
                {
                    case "Pending":
                        pendingCount++;
                        break;
                    case "In Progress":
                        inProgressCount++;
                        break;
                    case "Completed":
                        completedCount++;
                        break;
                }
            }
        }

        // Sort pendingAndInProgressOrders to show Pending orders first, then In Progress
        pendingAndInProgressOrders = pendingAndInProgressOrders
            .OrderByDescending(o => o.StatusBestelling == "Pending")
            .ThenByDescending(o => o.BestellingID)
            .ToList();

        StateHasChanged();
    }


    private RenderFragment RenderOrdersSection(string title, List<OrderWithProducts> orders) =>
        @<div class="orders-section">
            <h3>@title</h3>

            <div class="orders-container">
                @foreach (var order in orders)
                {
                    <div class="orders-card @GetOrderClass(order)" key="@order.BestellingID">
                        <div class="todo-title-wrapper">
                            <div class="todo-table-status-container">
                                <h4 class="table-number">Table @order.TafelID</h4>
                        <h5 class="status-text @GetOrderStatusClass(order.StatusBestelling)">@order.StatusBestelling@(":") @GetCompletionPercentage(order)%</h5>
                            </div>
                            <div>
                                <h4 class="order-id">#@order.BestellingID</h4>
                            </div>
                        </div>
                        <ul class="product-list-title-wrapper">
                            <li class="product-list-title">Amt</li>
                            <li class="product-list-title">Product</li>
                            <li class="product-list-title">Status</li>
                        </ul>
                        <ul class="product-list-wrapper">
                            @foreach (var product in order.Products)
                            {

                                <li class="@GetProductClass(product)" key="@product.ProductID">
                                    <span>@product.AantalProduct@("x")</span>
                                    @product.ProductNaam
                                    <input class="checkbox-round" type="checkbox"
                                           checked="@GetProductStatus(product)"
                                           @onchange="@(e => OnProductStatusChanged(e, order, product))" />
                                </li>
                            }
                        </ul>
                        <div class="btns-container">
                            <button class="cancel-btn" @onclick="() => OnCancelOrder(order)">Cancel</button>
                            <button class="serve-btn" @onclick="() => OnServeOrder(order)">Serve</button>
                        </div>
                    </div>
                }
            </div>
        </div>;


        // Method to determine the current status of the product.
        private bool GetProductStatus(ProductPerBestelronde product)
        {
            return product.StatusBesteldeProduct == "Completed";
        }

        // Method to handle the checkbox change event.
        private async Task OnProductStatusChanged(ChangeEventArgs e, OrderWithProducts order, ProductPerBestelronde product)
        {
            if ((bool)e.Value)
            {
                await CompleteTask(order, product);
            }
            else
            {
                await UncompleteTask(order, product);
            }
        }

        // This method is called when a product is marked as complete.
        private async Task CompleteTask(OrderWithProducts order, ProductPerBestelronde product)
        {
            Console.WriteLine($"Completing task for product {product.ProductID} in order {order.BestellingID}");

            // Update the product status in the Product_per_Bestelronde table to "Completed".
            await EmployeeService.UpdateProductStatusAsync(product.ProductID, product.BestelrondeID, "Completed");

            // Update the local status of the product to "Completed".
            product.StatusBesteldeProduct = "Completed";

            // Check if all products in the order are completed by querying the database.
            var allProductsCompleted = await EmployeeService.AreAllProductsCompletedAsync(order.BestellingID);
            Console.WriteLine($"All products completed: {allProductsCompleted}");
            // If all products are completed, update the order status to "Completed".
            order.StatusBestelling = allProductsCompleted ? "Completed" : "In Progress";
            await EmployeeService.UpdateOrderStatusAsync(order.BestellingID, order.StatusBestelling);
            
            // Refresh the component to show the updated state.
            await LoadOrdersByStatus();

        }

        private async Task UncompleteTask(OrderWithProducts order, ProductPerBestelronde product)
        {
            Console.WriteLine($"Uncompleting task for product {product.ProductID} in order {order.BestellingID}");

            // Update the product status in the Product_per_Bestelronde table to its previous state (e.g., "Pending").
            await EmployeeService.UpdateProductStatusAsync(product.ProductID, product.BestelrondeID, "Pending");

            // Update the local status of the product to "Pending".
            product.StatusBesteldeProduct = "Pending";

            // Check if all products in the order are completed by querying the database.
            var allProductsCompleted = await EmployeeService.AreAllProductsCompletedAsync(order.BestellingID);
            Console.WriteLine($"All products completed: {allProductsCompleted}");
            // If all products are completed, update the order status to "Completed".
            order.StatusBestelling = allProductsCompleted ? "Completed" : "In Progress";
            await EmployeeService.UpdateOrderStatusAsync(order.BestellingID, order.StatusBestelling);
            
            // Refresh the component to show the updated state.
            await LoadOrdersByStatus();

        }

        private async Task OnCancelOrder(OrderWithProducts order)
        {
            Console.WriteLine($"Cancelling order {order.BestellingID}");
            await EmployeeService.UpdateOrderStatusAsync(order.BestellingID, "Cancelled");
            await LoadOrdersByStatus();
        }

        private async Task OnServeOrder(OrderWithProducts order)
        {
            Console.WriteLine($"Serving order {order.BestellingID}");
            await EmployeeService.UpdateOrderStatusAsync(order.BestellingID, "Served");
            await LoadOrdersByStatus();
        }

        
        // The GetProductClass and GetOrderClass methods are used to determine the CSS class that should be applied to a product item in the UI based on its status.
        // Specifically, they checks whether the product's status is "Completed" and returns the appropriate CSS class.
        private string GetProductClass(ProductPerBestelronde product)
        {
            return product.StatusBesteldeProduct == "Completed" ? "completed-product" : string.Empty;
        }

        // This method returns the CSS class for an order based on its status.
        private string GetOrderClass(OrderWithProducts order)
        {
            return order.StatusBestelling == "Completed" ? "completed-order" : string.Empty;
            
        }

        private string GetOrderStatusClass(string status)
        {
            return status switch
            {
                "Pending" => "status_pending",
                "In Progress" => "status_in-progress",
                "Completed" => "status_completed",
                "Served" => "status_served",
                "Cancelled" => "status_cancelled",
                _ => string.Empty,
            };
        }

        private double GetCompletionPercentage(OrderWithProducts order)
        {
            if (order.Products == null || order.Products.Count == 0) return 0;
            var completedProducts = order.Products.Count(p => p.StatusBesteldeProduct == "Completed");
            return (completedProducts / (double)order.Products.Count) * 100;
        }


}
    
